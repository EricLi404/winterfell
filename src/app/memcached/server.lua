---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by eric.
--- DateTime: 2021/7/19 4:12 下午
---

local new_tab = require "table.new"
local str_sub = string.sub
local re_find = ngx.re.find
local mc_shdict = ngx.shared.memcached
local cjson = require "cjson"

local _M = { _VERSION = '0.01' }

local function parse_args(s)
    local arr = {}
    local start = 0
    while true do
        local from, to = re_find(s, [[\S+]], "jo", { pos = start })
        if not from then
            break
        end

        table.insert(arr, str_sub(s, from, to))

        start = to + 1
    end

    return arr
end

function _M.get(tcpsock, keys)
    local reply = ""

    for i = 2, #keys do
        local key = keys[i]
        local value, _flags = mc_shdict:get(key)
        if value then
            local flags = _flags or 0
            reply = reply .. "VALUE " .. key .. " " .. flags .. " " .. #value .. "\r\n" .. value .. "\r\n"
        end
    end
    reply = reply .. "END\r\n"

    tcpsock:settimeout(1000)  -- one second timeout
    local _, err = tcpsock:send(reply)
    if err then
        ngx.log(ngx.ERR, "failed to tcpsock:send ", err)
    end
end

function _M.set(tcpsock, res)
    local reply = ""

    local key = res[2]
    local flags = res[3]
    local exptime = res[4]
    local bytes = res[5]

    local value, err1 = tcpsock:receive(tonumber(bytes) + 2)
    if err1 then
        ngx.log(ngx.ERR, "failed to tcpsock:receive ", err1)
    end

    if str_sub(value, -2, -1) == "\r\n" then
        local succ, err2, forcible = mc_shdict:set(key, str_sub(value, 1, bytes), tonumber(exptime), tonumber(flags))
        if succ then
            reply = reply .. "STORED\r\n"
        else
            reply = reply .. "SERVER_ERROR " .. err2 .. "\r\n"
        end
    else
        reply = reply .. "ERROR\r\n"
    end

    tcpsock:settimeout(1000)  -- one second timeout
    local _, err3 = tcpsock:send(reply)
    if err3 then
        ngx.log(ngx.ERR, "failed to tcpsock:send ", err3)
    end
end

function _M.run()
    local tcpsock = assert(ngx.req.socket(true))
    tcpsock:settimeout(60000) -- 60 seconds
    while true do
        local data, err = tcpsock:receive("*l")
        if err then
            break
        end
        ngx.log(ngx.INFO, "cmd: ", "[[", data, "]]")
        if type(data) == "string" and #data > 0 then
            local cmd = parse_args(data)
            local args_len = #cmd
            if args_len > 0 then
                if cmd[1] == 'get' and args_len > 1 then
                    _M.get(tcpsock, cmd)
                elseif cmd[1] == "set" and args_len == 5 then
                    _M.set(tcpsock, cmd)
                end
            end
        end
        ngx.sleep(0.01)
    end
end

return _M